#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
FFT-based GPS L1 C/A acquisition with non-coherent integration
for IF samples generated by gps_if_sim.

Input file format (one sample per line):
    i_sign i_mag
where:
    sign: 0 = negative, 1 = positive
    mag : 0 => amplitude 1, 1 => amplitude 3
Reconstructed amplitude: {-3,-1,+1,+3}

Processing:
  1) Read IF samples and reconstruct amplitudes.
  2) Plot histogram and power spectrum of IF.
  3) Downconvert by nominal IF (f_if) to complex baseband.
  4) For each Doppler bin (residual fd around 0):
       For each 1ms block:
         - Mix by exp(-j 2Ï€ fd t)  (residual)
         - Correlate with local PRN replica using FFT:
             corr = IFFT( FFT(y) * conj(FFT(code)) )
         - Accumulate |corr|^2 across blocks (non-coherent)
     Choose peak over (fd, code_phase).

Outputs:
  - Best residual Doppler [Hz]
  - Best code delay as:
      * sample_offset within 1ms block [samples]
      * code_delay [chips] (converted from sample_offset)

Plots:
  - Histogram
  - Power spectrum
  - Correlation vs code delay (best Doppler bin)
"""

import argparse
import numpy as np
import matplotlib.pyplot as plt

CA_LEN = 1023
CHIP_RATE = 1.023e6  # chips/s


# ---------- C/A code generator (PRN 1..37) ----------
def generate_ca(prn: int) -> np.ndarray:
    """
    Generate GPS L1 C/A code chips (+1/-1), length 1023, PRN 1..37.
    G2 output: g2[t1-1] ^ g2[t2-1]
    """
    if not (1 <= prn <= 37):
        raise ValueError("PRN must be in 1..37")

    g2_taps = [
        (2, 6), (3, 7), (4, 8), (5, 9), (1, 9), (2, 10), (1, 8), (2, 9), (3, 10), (2, 3),
        (3, 4), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (1, 4), (2, 5), (3, 6), (4, 7),
        (5, 8), (6, 9), (1, 3), (4, 6), (5, 7), (6, 8), (7, 9), (8, 10), (1, 6), (2, 7),
        (3, 8), (4, 9), (5, 10), (4, 10), (1, 7), (2, 8), (4, 10)  # PRN37
    ]
    t1, t2 = g2_taps[prn - 1]

    g1 = np.ones(10, dtype=np.int8)
    g2 = np.ones(10, dtype=np.int8)

    ca = np.empty(CA_LEN, dtype=np.int8)
    for i in range(CA_LEN):
        g1_out = g1[9]
        g2_out = (g2[t1 - 1] ^ g2[t2 - 1]) & 1
        ca_bit = (g1_out ^ g2_out) & 1
        ca[i] = +1 if ca_bit == 0 else -1

        g1_fb = (g1[2] ^ g1[9]) & 1
        g2_fb = (g2[1] ^ g2[2] ^ g2[5] ^ g2[7] ^ g2[8] ^ g2[9]) & 1

        g1[1:] = g1[:-1]
        g1[0] = g1_fb
        g2[1:] = g2[:-1]
        g2[0] = g2_fb

    return ca


def make_code_samples(prn: int, fs: float, n_samp: int) -> np.ndarray:
    """
    Build 1ms (or n_samp) local code replica sampled at fs.
    Output: real array of +/-1, length n_samp
    """
    ca = generate_ca(prn).astype(np.int8)
    n = np.arange(n_samp)
    chip_idx = (np.floor(n * (CHIP_RATE / fs)).astype(np.int32) % CA_LEN)
    return ca[chip_idx].astype(np.float64)


# ---------- IO ----------
def read_if_2bit(path: str) -> np.ndarray:
    """
    Read gps_if_sim text output (i_sign i_mag) and reconstruct amplitude in {-3,-1,+1,+3}.
    """
    d = np.loadtxt(path, dtype=np.int8)
    if d.ndim == 1:
        d = d.reshape(-1, 2)
    sign = d[:, 0]
    mag = d[:, 1]
    amp = np.where(mag == 0, 1.0, 3.0) * np.where(sign == 0, -1.0, +1.0)
    return amp.astype(np.float64)


# ---------- Plots ----------
def plot_histogram(x: np.ndarray, title: str):
    plt.figure()
    levels = np.array([-3, -1, 1, 3], dtype=np.int32)
    counts = np.array([(x == v).sum() for v in levels], dtype=np.int64)
    plt.bar(levels, counts, width=1.0, edgecolor="black", align="center")
    plt.xticks(levels)
    plt.xlabel("Amplitude")
    plt.ylabel("Count")
    plt.title("IF sample histogram")
    plt.grid(True, axis="y")


def plot_power_spectrum(x: np.ndarray, fs: float, title: str):
    # Use a single FFT (windowed)
    N = min(len(x), 131072)
    xw = x[:N] * np.hanning(N)
    X = np.fft.fftshift(np.fft.fft(xw))
    f = np.fft.fftshift(np.fft.fftfreq(N, d=1.0 / fs))
    P = 20.0 * np.log10(np.abs(X) + 1e-12)

    plt.figure()
    plt.plot(f, P)
    plt.xlabel("Frequency [Hz]")
    plt.ylabel("Magnitude [dB]")
    plt.title(title)
    plt.grid(True)


def plot_corr_waveform(corr_nc: np.ndarray, fs: float, title: str):
    """
    corr_nc: non-coherent accumulated power vs sample offset (length Nms)
    """
    N = len(corr_nc)
    samp = np.arange(N)
    # sample offset -> chip delay (approx)
    chip = (samp * (CHIP_RATE / fs)) % CA_LEN

    plt.figure()
    plt.plot(chip, corr_nc)
    plt.xlabel("Code delay [chips] (mapped from sample offset)")
    plt.ylabel("Non-coherent correlation power")
    plt.title(title)
    plt.grid(True)


# ---------- FFT-based acquisition with non-coherent integration ----------
def acquire_fft_noncoherent(
    x_if: np.ndarray,
    prn: int,
    fs: float,
    f_if: float,
    fmin: float,
    fmax: float,
    fstep: float,
    ncoh_ms: int,
    start_ms: int = 0,
):
    """
    FFT-based circular correlation over 1ms blocks + non-coherent integration.

    Returns:
      best_fd (Hz), best_samp_offset (int),
      corr_nc_best (array len Nms) for best fd,
      freqs (array), peak_map (array len freqs)
    """
    # 1ms samples
    Nms = int(round(fs * 1e-3))
    if Nms <= 0:
        raise ValueError("fs too small?")

    # starting point (ms)
    start = start_ms * Nms
    x_if = x_if[start:]

    # how many full ms blocks are available
    nblocks_avail = len(x_if) // Nms
    nblocks = min(ncoh_ms, nblocks_avail)
    if nblocks <= 0:
        raise ValueError("Not enough samples for the requested non-coherent ms integration.")

    # local code (1ms sampled)
    code = make_code_samples(prn, fs, Nms)
    CODE = np.fft.fft(code)  # FFT of code (real)

    # time index for 1ms block
    n = np.arange(Nms)
    t = n / fs

    # precompute nominal IF mixing to complex baseband
    lo_if = np.exp(-1j * 2.0 * np.pi * f_if * t)

    freqs = np.arange(fmin, fmax + 0.5 * fstep, fstep, dtype=np.float64)
    peak_map = np.zeros(len(freqs), dtype=np.float64)

    best_fd = None
    best_samp_offset = None
    best_corr_nc = None
    best_peak = -1.0

    for i_f, fd in enumerate(freqs):
        # residual mixing for this fd
        lo_fd = np.exp(-1j * 2.0 * np.pi * fd * t)

        # non-coherent accumulator (power)
        corr_nc = np.zeros(Nms, dtype=np.float64)

        for b in range(nblocks):
            blk = x_if[b * Nms:(b + 1) * Nms]

            # downconvert: IF -> complex bb, and apply residual Doppler
            y = blk * lo_if * lo_fd

            # FFT-based circular correlation
            Y = np.fft.fft(y)
            corr = np.fft.ifft(Y * np.conj(CODE))  # complex correlation vs sample offset

            # non-coherent accumulate power
            corr_nc += (np.abs(corr) ** 2)

        # peak for this Doppler bin
        p = float(np.max(corr_nc))
        peak_map[i_f] = p

        if p > best_peak:
            best_peak = p
            best_fd = float(fd)
            best_samp_offset = int(np.argmax(corr_nc))
            best_corr_nc = corr_nc

    return best_fd, best_samp_offset, best_corr_nc, freqs, peak_map, Nms, nblocks


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--file", required=True, help="IF data file from gps_if_sim (i_sign i_mag per line)")
    ap.add_argument("--prn", type=int, required=True, help="PRN (1..37)")
    ap.add_argument("--fs", type=float, default=16.368e6, help="Sampling frequency [Hz] (default: 16.368e6)")
    ap.add_argument("--fif", type=float, default=4.092e6, help="Nominal IF center frequency [Hz] (default: 4.092e6)")
    ap.add_argument("--fmin", type=float, default=-5000.0, help="Min residual Doppler [Hz] (default: -5000)")
    ap.add_argument("--fmax", type=float, default=5000.0, help="Max residual Doppler [Hz] (default: 5000)")
    ap.add_argument("--fstep", type=float, default=500.0, help="Residual Doppler step [Hz] (default: 500)")
    ap.add_argument("--ncoh-ms", type=int, default=2, help="Non-coherent integration length [ms] (default: 2)")
    ap.add_argument("--start-ms", type=int, default=0, help="Start time offset [ms] into file (default: 0)")
    args = ap.parse_args()

    # read IF
    x = read_if_2bit(args.file)
    print(f"Loaded {len(x)} samples from {args.file}")

    # plots
    plot_histogram(x, "IF sample histogram")
    plot_power_spectrum(x, args.fs, "IF power spectrum")

    # acquisition
    print("Running FFT-based acquisition with non-coherent integration ...")
    best_fd, best_samp, corr_nc_best, freqs, peak_map, Nms, nblocks = acquire_fft_noncoherent(
        x_if=x,
        prn=args.prn,
        fs=args.fs,
        f_if=args.fif,
        fmin=args.fmin,
        fmax=args.fmax,
        fstep=args.fstep,
        ncoh_ms=args.ncoh_ms,
        start_ms=args.start_ms,
    )

    # convert sample offset to chip delay (approx)
    chip_delay = (best_samp * (CHIP_RATE / args.fs)) % CA_LEN

    print("\n=== Acquisition Result ===")
    print(f"  PRN                 : {args.prn}")
    print(f"  Fs                  : {args.fs:.3f} Hz")
    print(f"  Nominal IF          : {args.fif:.3f} Hz")
    print(f"  Non-coherent blocks : {nblocks} ms")
    print(f"  Best residual Doppler (fd) : {best_fd:.1f} Hz")
    print(f"  Best code offset (samples) : {best_samp} / {Nms} samples per ms")
    print(f"  Best code delay (chips) : {chip_delay:.3f} chips")

    # plot correlation waveform at best Doppler
    plot_corr_waveform(
        corr_nc_best,
        fs=args.fs,
        title=f"Non-coherent correlation vs code delay (PRN {args.prn}, fd={best_fd:.1f} Hz, {nblocks}ms)"
    )

    # optional: show Doppler bin peak curve (useful)
    plt.figure()
    plt.plot(freqs, peak_map)
    plt.xlabel("Residual Doppler [Hz]")
    plt.ylabel("Peak non-coherent correlation power")
    plt.title("Doppler search peak metric")
    plt.grid(True)

    plt.show()


if __name__ == "__main__":
    main()
